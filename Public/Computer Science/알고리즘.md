# 목차

[`완전검색`](#완전검색), [`Greedy`](#탐욕알고리즘), [`동적계획법`](#동적계획법), [`Memorization`](#Memorization), [`시간복잡도`](#시간복잡도), [`공간복잡도`](#공간복잡도), [`버블정렬`](#버블정렬), [`카운팅정렬`](#카운팅정렬), [`선택정렬`](#선택정렬), [`합병정렬`](#합병정렬), [`퀵정렬`](#퀵정렬), [`삽입정렬`](#삽입정렬)

[`순차검색`](#순차검색), [`이진검색`](#이진검색)

# 내용

## 알고리즘

### 최적해찾기

#### 완전검색

- Brute-force
- 모든 경우의 수를 나열해보고 확인하는 방법
- 경우의 수가 적을 때 유용

#### 탐욕알고리즘

- Greedy
- 최적화 문제에서 최적해를 구하는데 사용
- 여러 경우 중 선택할 때 최적이라고 생각되는 것을 선택해 나가는 방식

#### 동적계획법

- DP (Dynamic Programming)
- 복잡한 문제를 간단한 여러 개의 하위 문제(sub-problem)로 나누어 푸는 방법을 말한다.

### Memorization

- 재귀함수에서 중복 호출을 막기위한 방법으로 이전에 계산했던 값은 메모리에 저장하여 다시 계산하지 않도록 함

### 시간복잡도

> “얼마나 빠르게 실행되느냐”

- 알고리즘을 수행하는 데 연산들이 몇 번 이루어지는 지

### 공간복잡도

> “얼마나 많은 자원이 필요한가”

- 완료하는 데 필요로 하는 자원 공간의 양

### 정렬

#### 버블정렬

- 인접한 원소끼리 계속 자리를 교환
- 시간복잡도 : O(n^2)
- 공간복잡도 : O(1)

#### 카운팅정렬

- 몇 개인지 개수를 세어 정렬하는 방식
- 최대값을 알아야하고, 정수인 경우에만 가능
- 시간복잡도 : O(n+k) (n: 리스트길이, k: 정수의 최대값)
- 공간복잡도 : O(n)

#### 선택정렬

- 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식
- 시간복잡도 : O(n^2)
- 공간복잡도 : O(1)

#### 합병정렬

- 나누어지지 않을 때까지 반 씩 분할하다가 반환된 값을 비교하여 합병하면서 정렬한다.

- 시간복잡도 : O(nlogn)
- 공간복잡도 : O(n)

#### 퀵정렬

- 합병은 반씩 나누었다면 퀵은 `pivot`을 이용하여 기준점을 만든다. 이 때 기준보다 작은 값은 왼편으로 큰 값은 오른편으로 위치시키고 이러한 과정을 재귀적으로 반복하여 정렬한다.
- 시간복잡도 : O(nlogn) / 최악의 경우에는 O(n^2)
- 공간복잡도 : O(1)

#### 삽입정렬

- 정렬되지 않은 원소를 정렬된 부분의 모든 원소들과 비교하여 위치를 찾아 삽입한다.
- 시간복잡도 : O(n^2)
- 공간복잡도 : O(1)

### 검색

#### 순차검색

- 가장 간단하고 직관적
- 순차구조에 유용함
- 시간복잡도 : O(n)

#### 이진검색

- 자료가 정렬되어 있을 때만 가능
- 자료의 가운데 값과 비교하여 다음 검색방향을 결정함
- 시간복잡도 : O(logn)